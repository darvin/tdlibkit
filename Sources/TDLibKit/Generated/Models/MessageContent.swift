//
//  MessageContent.swift
//  tl2swift
//
//  Generated automatically. Any changes will be lost!
//  Based on TDLib 1.8.4-1dec0e20
//  https://github.com/tdlib/td/tree/1dec0e20
//

import Foundation


/// Contains the content of a message
public enum MessageContent: Codable, Equatable, Hashable {

    /// A text message
    case text(MessageText)

    /// An animation message (GIF-style).
    case animation(MessageAnimation)

    /// An audio message
    case audio(MessageAudio)

    /// A document message (general file)
    case document(MessageDocument)

    /// A photo message
    case photo(MessagePhoto)

    /// An expired photo message (self-destructed after TTL has elapsed)
    case expiredPhoto

    /// A sticker message
    case sticker(MessageSticker)

    /// A video message
    case video(MessageVideo)

    /// An expired video message (self-destructed after TTL has elapsed)
    case expiredVideo

    /// A video note message
    case videoNote(MessageVideoNote)

    /// A voice note message
    case voiceNote(MessageVoiceNote)

    /// A message with a location
    case location(MessageLocation)

    /// A message with information about a venue
    case venue(MessageVenue)

    /// A message with a user contact
    case contact(MessageContact)

    /// A message with an animated emoji
    case animatedEmoji(MessageAnimatedEmoji)

    /// A dice message. The dice value is randomly generated by the server
    case dice(MessageDice)

    /// A message with a game
    case game(MessageGame)

    /// A message with a poll
    case poll(MessagePoll)

    /// A message with an invoice from a bot
    case invoice(MessageInvoice)

    /// A message with information about an ended call
    case call(MessageCall)

    /// A new video chat was scheduled
    case videoChatScheduled(MessageVideoChatScheduled)

    /// A newly created video chat
    case videoChatStarted(MessageVideoChatStarted)

    /// A message with information about an ended video chat
    case videoChatEnded(MessageVideoChatEnded)

    /// A message with information about an invite to a video chat
    case inviteVideoChatParticipants(MessageInviteVideoChatParticipants)

    /// A newly created basic group
    case basicGroupChatCreate(MessageBasicGroupChatCreate)

    /// A newly created supergroup or channel
    case supergroupChatCreate(MessageSupergroupChatCreate)

    /// An updated chat title
    case chatChangeTitle(MessageChatChangeTitle)

    /// An updated chat photo
    case chatChangePhoto(MessageChatChangePhoto)

    /// A deleted chat photo
    case chatDeletePhoto

    /// New chat members were added
    case chatAddMembers(MessageChatAddMembers)

    /// A new member joined the chat via an invite link
    case chatJoinByLink

    /// A new member was accepted to the chat by an administrator
    case chatJoinByRequest

    /// A chat member was deleted
    case chatDeleteMember(MessageChatDeleteMember)

    /// A basic group was upgraded to a supergroup and was deactivated as the result
    case chatUpgradeTo(MessageChatUpgradeTo)

    /// A supergroup has been created from a basic group
    case chatUpgradeFrom(MessageChatUpgradeFrom)

    /// A message has been pinned
    case pinMessage(MessagePinMessage)

    /// A screenshot of a message in the chat has been taken
    case screenshotTaken

    /// A theme in the chat has been changed
    case chatSetTheme(MessageChatSetTheme)

    /// The TTL (Time To Live) setting for messages in the chat has been changed
    case chatSetTtl(MessageChatSetTtl)

    /// A non-standard action has happened in the chat
    case customServiceAction(MessageCustomServiceAction)

    /// A new high score was achieved in a game
    case gameScore(MessageGameScore)

    /// A payment has been completed
    case paymentSuccessful(MessagePaymentSuccessful)

    /// A payment has been completed; for bots only
    case paymentSuccessfulBot(MessagePaymentSuccessfulBot)

    /// A contact has registered with Telegram
    case contactRegistered

    /// The current user has connected a website by logging in using Telegram Login Widget on it
    case websiteConnected(MessageWebsiteConnected)

    /// Data from a Web App has been sent to a bot
    case webAppDataSent(MessageWebAppDataSent)

    /// Data from a Web App has been received; for bots only
    case webAppDataReceived(MessageWebAppDataReceived)

    /// Telegram Passport data has been sent to a bot
    case passportDataSent(MessagePassportDataSent)

    /// Telegram Passport data has been received; for bots only
    case passportDataReceived(MessagePassportDataReceived)

    /// A user in the chat came within proximity alert range
    case proximityAlertTriggered(MessageProximityAlertTriggered)

    /// Message content that is not supported in the current TDLib version
    case unsupported


    private enum Kind: String, Codable {
        case messageText
        case messageAnimation
        case messageAudio
        case messageDocument
        case messagePhoto
        case messageExpiredPhoto
        case messageSticker
        case messageVideo
        case messageExpiredVideo
        case messageVideoNote
        case messageVoiceNote
        case messageLocation
        case messageVenue
        case messageContact
        case messageAnimatedEmoji
        case messageDice
        case messageGame
        case messagePoll
        case messageInvoice
        case messageCall
        case messageVideoChatScheduled
        case messageVideoChatStarted
        case messageVideoChatEnded
        case messageInviteVideoChatParticipants
        case messageBasicGroupChatCreate
        case messageSupergroupChatCreate
        case messageChatChangeTitle
        case messageChatChangePhoto
        case messageChatDeletePhoto
        case messageChatAddMembers
        case messageChatJoinByLink
        case messageChatJoinByRequest
        case messageChatDeleteMember
        case messageChatUpgradeTo
        case messageChatUpgradeFrom
        case messagePinMessage
        case messageScreenshotTaken
        case messageChatSetTheme
        case messageChatSetTtl
        case messageCustomServiceAction
        case messageGameScore
        case messagePaymentSuccessful
        case messagePaymentSuccessfulBot
        case messageContactRegistered
        case messageWebsiteConnected
        case messageWebAppDataSent
        case messageWebAppDataReceived
        case messagePassportDataSent
        case messagePassportDataReceived
        case messageProximityAlertTriggered
        case messageUnsupported
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DtoCodingKeys.self)
        let type = try container.decode(Kind.self, forKey: .type)
        switch type {
        case .messageText:
            let value = try MessageText(from: decoder)
            self = .text(value)
        case .messageAnimation:
            let value = try MessageAnimation(from: decoder)
            self = .animation(value)
        case .messageAudio:
            let value = try MessageAudio(from: decoder)
            self = .audio(value)
        case .messageDocument:
            let value = try MessageDocument(from: decoder)
            self = .document(value)
        case .messagePhoto:
            let value = try MessagePhoto(from: decoder)
            self = .photo(value)
        case .messageExpiredPhoto:
            self = .expiredPhoto
        case .messageSticker:
            let value = try MessageSticker(from: decoder)
            self = .sticker(value)
        case .messageVideo:
            let value = try MessageVideo(from: decoder)
            self = .video(value)
        case .messageExpiredVideo:
            self = .expiredVideo
        case .messageVideoNote:
            let value = try MessageVideoNote(from: decoder)
            self = .videoNote(value)
        case .messageVoiceNote:
            let value = try MessageVoiceNote(from: decoder)
            self = .voiceNote(value)
        case .messageLocation:
            let value = try MessageLocation(from: decoder)
            self = .location(value)
        case .messageVenue:
            let value = try MessageVenue(from: decoder)
            self = .venue(value)
        case .messageContact:
            let value = try MessageContact(from: decoder)
            self = .contact(value)
        case .messageAnimatedEmoji:
            let value = try MessageAnimatedEmoji(from: decoder)
            self = .animatedEmoji(value)
        case .messageDice:
            let value = try MessageDice(from: decoder)
            self = .dice(value)
        case .messageGame:
            let value = try MessageGame(from: decoder)
            self = .game(value)
        case .messagePoll:
            let value = try MessagePoll(from: decoder)
            self = .poll(value)
        case .messageInvoice:
            let value = try MessageInvoice(from: decoder)
            self = .invoice(value)
        case .messageCall:
            let value = try MessageCall(from: decoder)
            self = .call(value)
        case .messageVideoChatScheduled:
            let value = try MessageVideoChatScheduled(from: decoder)
            self = .videoChatScheduled(value)
        case .messageVideoChatStarted:
            let value = try MessageVideoChatStarted(from: decoder)
            self = .videoChatStarted(value)
        case .messageVideoChatEnded:
            let value = try MessageVideoChatEnded(from: decoder)
            self = .videoChatEnded(value)
        case .messageInviteVideoChatParticipants:
            let value = try MessageInviteVideoChatParticipants(from: decoder)
            self = .inviteVideoChatParticipants(value)
        case .messageBasicGroupChatCreate:
            let value = try MessageBasicGroupChatCreate(from: decoder)
            self = .basicGroupChatCreate(value)
        case .messageSupergroupChatCreate:
            let value = try MessageSupergroupChatCreate(from: decoder)
            self = .supergroupChatCreate(value)
        case .messageChatChangeTitle:
            let value = try MessageChatChangeTitle(from: decoder)
            self = .chatChangeTitle(value)
        case .messageChatChangePhoto:
            let value = try MessageChatChangePhoto(from: decoder)
            self = .chatChangePhoto(value)
        case .messageChatDeletePhoto:
            self = .chatDeletePhoto
        case .messageChatAddMembers:
            let value = try MessageChatAddMembers(from: decoder)
            self = .chatAddMembers(value)
        case .messageChatJoinByLink:
            self = .chatJoinByLink
        case .messageChatJoinByRequest:
            self = .chatJoinByRequest
        case .messageChatDeleteMember:
            let value = try MessageChatDeleteMember(from: decoder)
            self = .chatDeleteMember(value)
        case .messageChatUpgradeTo:
            let value = try MessageChatUpgradeTo(from: decoder)
            self = .chatUpgradeTo(value)
        case .messageChatUpgradeFrom:
            let value = try MessageChatUpgradeFrom(from: decoder)
            self = .chatUpgradeFrom(value)
        case .messagePinMessage:
            let value = try MessagePinMessage(from: decoder)
            self = .pinMessage(value)
        case .messageScreenshotTaken:
            self = .screenshotTaken
        case .messageChatSetTheme:
            let value = try MessageChatSetTheme(from: decoder)
            self = .chatSetTheme(value)
        case .messageChatSetTtl:
            let value = try MessageChatSetTtl(from: decoder)
            self = .chatSetTtl(value)
        case .messageCustomServiceAction:
            let value = try MessageCustomServiceAction(from: decoder)
            self = .customServiceAction(value)
        case .messageGameScore:
            let value = try MessageGameScore(from: decoder)
            self = .gameScore(value)
        case .messagePaymentSuccessful:
            let value = try MessagePaymentSuccessful(from: decoder)
            self = .paymentSuccessful(value)
        case .messagePaymentSuccessfulBot:
            let value = try MessagePaymentSuccessfulBot(from: decoder)
            self = .paymentSuccessfulBot(value)
        case .messageContactRegistered:
            self = .contactRegistered
        case .messageWebsiteConnected:
            let value = try MessageWebsiteConnected(from: decoder)
            self = .websiteConnected(value)
        case .messageWebAppDataSent:
            let value = try MessageWebAppDataSent(from: decoder)
            self = .webAppDataSent(value)
        case .messageWebAppDataReceived:
            let value = try MessageWebAppDataReceived(from: decoder)
            self = .webAppDataReceived(value)
        case .messagePassportDataSent:
            let value = try MessagePassportDataSent(from: decoder)
            self = .passportDataSent(value)
        case .messagePassportDataReceived:
            let value = try MessagePassportDataReceived(from: decoder)
            self = .passportDataReceived(value)
        case .messageProximityAlertTriggered:
            let value = try MessageProximityAlertTriggered(from: decoder)
            self = .proximityAlertTriggered(value)
        case .messageUnsupported:
            self = .unsupported
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: DtoCodingKeys.self)
        switch self {
        case .text(let value):
            try container.encode(Kind.messageText, forKey: .type)
            try value.encode(to: encoder)
        case .animation(let value):
            try container.encode(Kind.messageAnimation, forKey: .type)
            try value.encode(to: encoder)
        case .audio(let value):
            try container.encode(Kind.messageAudio, forKey: .type)
            try value.encode(to: encoder)
        case .document(let value):
            try container.encode(Kind.messageDocument, forKey: .type)
            try value.encode(to: encoder)
        case .photo(let value):
            try container.encode(Kind.messagePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .expiredPhoto:
            try container.encode(Kind.messageExpiredPhoto, forKey: .type)
        case .sticker(let value):
            try container.encode(Kind.messageSticker, forKey: .type)
            try value.encode(to: encoder)
        case .video(let value):
            try container.encode(Kind.messageVideo, forKey: .type)
            try value.encode(to: encoder)
        case .expiredVideo:
            try container.encode(Kind.messageExpiredVideo, forKey: .type)
        case .videoNote(let value):
            try container.encode(Kind.messageVideoNote, forKey: .type)
            try value.encode(to: encoder)
        case .voiceNote(let value):
            try container.encode(Kind.messageVoiceNote, forKey: .type)
            try value.encode(to: encoder)
        case .location(let value):
            try container.encode(Kind.messageLocation, forKey: .type)
            try value.encode(to: encoder)
        case .venue(let value):
            try container.encode(Kind.messageVenue, forKey: .type)
            try value.encode(to: encoder)
        case .contact(let value):
            try container.encode(Kind.messageContact, forKey: .type)
            try value.encode(to: encoder)
        case .animatedEmoji(let value):
            try container.encode(Kind.messageAnimatedEmoji, forKey: .type)
            try value.encode(to: encoder)
        case .dice(let value):
            try container.encode(Kind.messageDice, forKey: .type)
            try value.encode(to: encoder)
        case .game(let value):
            try container.encode(Kind.messageGame, forKey: .type)
            try value.encode(to: encoder)
        case .poll(let value):
            try container.encode(Kind.messagePoll, forKey: .type)
            try value.encode(to: encoder)
        case .invoice(let value):
            try container.encode(Kind.messageInvoice, forKey: .type)
            try value.encode(to: encoder)
        case .call(let value):
            try container.encode(Kind.messageCall, forKey: .type)
            try value.encode(to: encoder)
        case .videoChatScheduled(let value):
            try container.encode(Kind.messageVideoChatScheduled, forKey: .type)
            try value.encode(to: encoder)
        case .videoChatStarted(let value):
            try container.encode(Kind.messageVideoChatStarted, forKey: .type)
            try value.encode(to: encoder)
        case .videoChatEnded(let value):
            try container.encode(Kind.messageVideoChatEnded, forKey: .type)
            try value.encode(to: encoder)
        case .inviteVideoChatParticipants(let value):
            try container.encode(Kind.messageInviteVideoChatParticipants, forKey: .type)
            try value.encode(to: encoder)
        case .basicGroupChatCreate(let value):
            try container.encode(Kind.messageBasicGroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case .supergroupChatCreate(let value):
            try container.encode(Kind.messageSupergroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case .chatChangeTitle(let value):
            try container.encode(Kind.messageChatChangeTitle, forKey: .type)
            try value.encode(to: encoder)
        case .chatChangePhoto(let value):
            try container.encode(Kind.messageChatChangePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .chatDeletePhoto:
            try container.encode(Kind.messageChatDeletePhoto, forKey: .type)
        case .chatAddMembers(let value):
            try container.encode(Kind.messageChatAddMembers, forKey: .type)
            try value.encode(to: encoder)
        case .chatJoinByLink:
            try container.encode(Kind.messageChatJoinByLink, forKey: .type)
        case .chatJoinByRequest:
            try container.encode(Kind.messageChatJoinByRequest, forKey: .type)
        case .chatDeleteMember(let value):
            try container.encode(Kind.messageChatDeleteMember, forKey: .type)
            try value.encode(to: encoder)
        case .chatUpgradeTo(let value):
            try container.encode(Kind.messageChatUpgradeTo, forKey: .type)
            try value.encode(to: encoder)
        case .chatUpgradeFrom(let value):
            try container.encode(Kind.messageChatUpgradeFrom, forKey: .type)
            try value.encode(to: encoder)
        case .pinMessage(let value):
            try container.encode(Kind.messagePinMessage, forKey: .type)
            try value.encode(to: encoder)
        case .screenshotTaken:
            try container.encode(Kind.messageScreenshotTaken, forKey: .type)
        case .chatSetTheme(let value):
            try container.encode(Kind.messageChatSetTheme, forKey: .type)
            try value.encode(to: encoder)
        case .chatSetTtl(let value):
            try container.encode(Kind.messageChatSetTtl, forKey: .type)
            try value.encode(to: encoder)
        case .customServiceAction(let value):
            try container.encode(Kind.messageCustomServiceAction, forKey: .type)
            try value.encode(to: encoder)
        case .gameScore(let value):
            try container.encode(Kind.messageGameScore, forKey: .type)
            try value.encode(to: encoder)
        case .paymentSuccessful(let value):
            try container.encode(Kind.messagePaymentSuccessful, forKey: .type)
            try value.encode(to: encoder)
        case .paymentSuccessfulBot(let value):
            try container.encode(Kind.messagePaymentSuccessfulBot, forKey: .type)
            try value.encode(to: encoder)
        case .contactRegistered:
            try container.encode(Kind.messageContactRegistered, forKey: .type)
        case .websiteConnected(let value):
            try container.encode(Kind.messageWebsiteConnected, forKey: .type)
            try value.encode(to: encoder)
        case .webAppDataSent(let value):
            try container.encode(Kind.messageWebAppDataSent, forKey: .type)
            try value.encode(to: encoder)
        case .webAppDataReceived(let value):
            try container.encode(Kind.messageWebAppDataReceived, forKey: .type)
            try value.encode(to: encoder)
        case .passportDataSent(let value):
            try container.encode(Kind.messagePassportDataSent, forKey: .type)
            try value.encode(to: encoder)
        case .passportDataReceived(let value):
            try container.encode(Kind.messagePassportDataReceived, forKey: .type)
            try value.encode(to: encoder)
        case .proximityAlertTriggered(let value):
            try container.encode(Kind.messageProximityAlertTriggered, forKey: .type)
            try value.encode(to: encoder)
        case .unsupported:
            try container.encode(Kind.messageUnsupported, forKey: .type)
        }
    }
}

/// A text message
public struct MessageText: Codable, Equatable, Hashable {

    /// Text of the message
    public let text: FormattedText

    /// A preview of the web page that's mentioned in the text; may be null
    public let webPage: WebPage?


    public init(
        text: FormattedText,
        webPage: WebPage?
    ) {
        self.text = text
        self.webPage = webPage
    }
}

/// An animation message (GIF-style).
public struct MessageAnimation: Codable, Equatable, Hashable {

    /// The animation description
    public let animation: Animation

    /// Animation caption
    public let caption: FormattedText

    /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
    public let isSecret: Bool


    public init(
        animation: Animation,
        caption: FormattedText,
        isSecret: Bool
    ) {
        self.animation = animation
        self.caption = caption
        self.isSecret = isSecret
    }
}

/// An audio message
public struct MessageAudio: Codable, Equatable, Hashable {

    /// The audio description
    public let audio: Audio

    /// Audio caption
    public let caption: FormattedText


    public init(
        audio: Audio,
        caption: FormattedText
    ) {
        self.audio = audio
        self.caption = caption
    }
}

/// A document message (general file)
public struct MessageDocument: Codable, Equatable, Hashable {

    /// Document caption
    public let caption: FormattedText

    /// The document description
    public let document: Document


    public init(
        caption: FormattedText,
        document: Document
    ) {
        self.caption = caption
        self.document = document
    }
}

/// A photo message
public struct MessagePhoto: Codable, Equatable, Hashable {

    /// Photo caption
    public let caption: FormattedText

    /// True, if the photo must be blurred and must be shown only while tapped
    public let isSecret: Bool

    /// The photo description
    public let photo: Photo


    public init(
        caption: FormattedText,
        isSecret: Bool,
        photo: Photo
    ) {
        self.caption = caption
        self.isSecret = isSecret
        self.photo = photo
    }
}

/// A sticker message
public struct MessageSticker: Codable, Equatable, Hashable {

    /// True, if premium animation of the sticker must be played
    public let isPremium: Bool

    /// The sticker description
    public let sticker: Sticker


    public init(
        isPremium: Bool,
        sticker: Sticker
    ) {
        self.isPremium = isPremium
        self.sticker = sticker
    }
}

/// A video message
public struct MessageVideo: Codable, Equatable, Hashable {

    /// Video caption
    public let caption: FormattedText

    /// True, if the video thumbnail must be blurred and the video must be shown only while tapped
    public let isSecret: Bool

    /// The video description
    public let video: Video


    public init(
        caption: FormattedText,
        isSecret: Bool,
        video: Video
    ) {
        self.caption = caption
        self.isSecret = isSecret
        self.video = video
    }
}

/// A video note message
public struct MessageVideoNote: Codable, Equatable, Hashable {

    /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
    public let isSecret: Bool

    /// True, if at least one of the recipients has viewed the video note
    public let isViewed: Bool

    /// The video note description
    public let videoNote: VideoNote


    public init(
        isSecret: Bool,
        isViewed: Bool,
        videoNote: VideoNote
    ) {
        self.isSecret = isSecret
        self.isViewed = isViewed
        self.videoNote = videoNote
    }
}

/// A voice note message
public struct MessageVoiceNote: Codable, Equatable, Hashable {

    /// Voice note caption
    public let caption: FormattedText

    /// True, if at least one of the recipients has listened to the voice note
    public let isListened: Bool

    /// The voice note description
    public let voiceNote: VoiceNote


    public init(
        caption: FormattedText,
        isListened: Bool,
        voiceNote: VoiceNote
    ) {
        self.caption = caption
        self.isListened = isListened
        self.voiceNote = voiceNote
    }
}

/// A message with a location
public struct MessageLocation: Codable, Equatable, Hashable {

    /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
    public let expiresIn: Int

    /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
    public let heading: Int

    /// Time relative to the message send date, for which the location can be updated, in seconds
    public let livePeriod: Int

    /// The location description
    public let location: Location

    /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender
    public let proximityAlertRadius: Int


    public init(
        expiresIn: Int,
        heading: Int,
        livePeriod: Int,
        location: Location,
        proximityAlertRadius: Int
    ) {
        self.expiresIn = expiresIn
        self.heading = heading
        self.livePeriod = livePeriod
        self.location = location
        self.proximityAlertRadius = proximityAlertRadius
    }
}

/// A message with information about a venue
public struct MessageVenue: Codable, Equatable, Hashable {

    /// The venue description
    public let venue: Venue


    public init(venue: Venue) {
        self.venue = venue
    }
}

/// A message with a user contact
public struct MessageContact: Codable, Equatable, Hashable {

    /// The contact description
    public let contact: Contact


    public init(contact: Contact) {
        self.contact = contact
    }
}

/// A message with an animated emoji
public struct MessageAnimatedEmoji: Codable, Equatable, Hashable {

    /// The animated emoji
    public let animatedEmoji: AnimatedEmoji

    /// The corresponding emoji
    public let emoji: String


    public init(
        animatedEmoji: AnimatedEmoji,
        emoji: String
    ) {
        self.animatedEmoji = animatedEmoji
        self.emoji = emoji
    }
}

/// A dice message. The dice value is randomly generated by the server
public struct MessageDice: Codable, Equatable, Hashable {

    /// Emoji on which the dice throw animation is based
    public let emoji: String

    /// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    public let finalState: DiceStickers?

    /// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    public let initialState: DiceStickers?

    /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
    public let successAnimationFrameNumber: Int

    /// The dice value. If the value is 0, the dice don't have final state yet
    public let value: Int


    public init(
        emoji: String,
        finalState: DiceStickers?,
        initialState: DiceStickers?,
        successAnimationFrameNumber: Int,
        value: Int
    ) {
        self.emoji = emoji
        self.finalState = finalState
        self.initialState = initialState
        self.successAnimationFrameNumber = successAnimationFrameNumber
        self.value = value
    }
}

/// A message with a game
public struct MessageGame: Codable, Equatable, Hashable {

    /// The game description
    public let game: Game


    public init(game: Game) {
        self.game = game
    }
}

/// A message with a poll
public struct MessagePoll: Codable, Equatable, Hashable {

    /// The poll description
    public let poll: Poll


    public init(poll: Poll) {
        self.poll = poll
    }
}

/// A message with an invoice from a bot
public struct MessageInvoice: Codable, Equatable, Hashable {

    /// Currency for the product price
    public let currency: String

    public let description: FormattedText

    /// True, if the invoice is a test invoice
    public let isTest: Bool

    /// True, if the shipping address must be specified
    public let needShippingAddress: Bool

    /// Product photo; may be null
    public let photo: Photo?

    /// The identifier of the message with the receipt, after the product has been purchased
    public let receiptMessageId: Int64

    /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
    public let startParameter: String

    /// Product title
    public let title: String

    /// Product total price in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        description: FormattedText,
        isTest: Bool,
        needShippingAddress: Bool,
        photo: Photo?,
        receiptMessageId: Int64,
        startParameter: String,
        title: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.description = description
        self.isTest = isTest
        self.needShippingAddress = needShippingAddress
        self.photo = photo
        self.receiptMessageId = receiptMessageId
        self.startParameter = startParameter
        self.title = title
        self.totalAmount = totalAmount
    }
}

/// A message with information about an ended call
public struct MessageCall: Codable, Equatable, Hashable {

    /// Reason why the call was discarded
    public let discardReason: CallDiscardReason

    /// Call duration, in seconds
    public let duration: Int

    /// True, if the call was a video call
    public let isVideo: Bool


    public init(
        discardReason: CallDiscardReason,
        duration: Int,
        isVideo: Bool
    ) {
        self.discardReason = discardReason
        self.duration = duration
        self.isVideo = isVideo
    }
}

/// A new video chat was scheduled
public struct MessageVideoChatScheduled: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int

    /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
    public let startDate: Int


    public init(
        groupCallId: Int,
        startDate: Int
    ) {
        self.groupCallId = groupCallId
        self.startDate = startDate
    }
}

/// A newly created video chat
public struct MessageVideoChatStarted: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int


    public init(groupCallId: Int) {
        self.groupCallId = groupCallId
    }
}

/// A message with information about an ended video chat
public struct MessageVideoChatEnded: Codable, Equatable, Hashable {

    /// Call duration, in seconds
    public let duration: Int


    public init(duration: Int) {
        self.duration = duration
    }
}

/// A message with information about an invite to a video chat
public struct MessageInviteVideoChatParticipants: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int

    /// Invited user identifiers
    public let userIds: [Int64]


    public init(
        groupCallId: Int,
        userIds: [Int64]
    ) {
        self.groupCallId = groupCallId
        self.userIds = userIds
    }
}

/// A newly created basic group
public struct MessageBasicGroupChatCreate: Codable, Equatable, Hashable {

    /// User identifiers of members in the basic group
    public let memberUserIds: [Int64]

    /// Title of the basic group
    public let title: String


    public init(
        memberUserIds: [Int64],
        title: String
    ) {
        self.memberUserIds = memberUserIds
        self.title = title
    }
}

/// A newly created supergroup or channel
public struct MessageSupergroupChatCreate: Codable, Equatable, Hashable {

    /// Title of the supergroup or channel
    public let title: String


    public init(title: String) {
        self.title = title
    }
}

/// An updated chat title
public struct MessageChatChangeTitle: Codable, Equatable, Hashable {

    /// New chat title
    public let title: String


    public init(title: String) {
        self.title = title
    }
}

/// An updated chat photo
public struct MessageChatChangePhoto: Codable, Equatable, Hashable {

    /// New chat photo
    public let photo: ChatPhoto


    public init(photo: ChatPhoto) {
        self.photo = photo
    }
}

/// New chat members were added
public struct MessageChatAddMembers: Codable, Equatable, Hashable {

    /// User identifiers of the new members
    public let memberUserIds: [Int64]


    public init(memberUserIds: [Int64]) {
        self.memberUserIds = memberUserIds
    }
}

/// A chat member was deleted
public struct MessageChatDeleteMember: Codable, Equatable, Hashable {

    /// User identifier of the deleted chat member
    public let userId: Int64


    public init(userId: Int64) {
        self.userId = userId
    }
}

/// A basic group was upgraded to a supergroup and was deactivated as the result
public struct MessageChatUpgradeTo: Codable, Equatable, Hashable {

    /// Identifier of the supergroup to which the basic group was upgraded
    public let supergroupId: Int64


    public init(supergroupId: Int64) {
        self.supergroupId = supergroupId
    }
}

/// A supergroup has been created from a basic group
public struct MessageChatUpgradeFrom: Codable, Equatable, Hashable {

    /// The identifier of the original basic group
    public let basicGroupId: Int64

    /// Title of the newly created supergroup
    public let title: String


    public init(
        basicGroupId: Int64,
        title: String
    ) {
        self.basicGroupId = basicGroupId
        self.title = title
    }
}

/// A message has been pinned
public struct MessagePinMessage: Codable, Equatable, Hashable {

    /// Identifier of the pinned message, can be an identifier of a deleted message or 0
    public let messageId: Int64


    public init(messageId: Int64) {
        self.messageId = messageId
    }
}

/// A theme in the chat has been changed
public struct MessageChatSetTheme: Codable, Equatable, Hashable {

    /// If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
    public let themeName: String


    public init(themeName: String) {
        self.themeName = themeName
    }
}

/// The TTL (Time To Live) setting for messages in the chat has been changed
public struct MessageChatSetTtl: Codable, Equatable, Hashable {

    /// New message TTL
    public let ttl: Int


    public init(ttl: Int) {
        self.ttl = ttl
    }
}

/// A non-standard action has happened in the chat
public struct MessageCustomServiceAction: Codable, Equatable, Hashable {

    /// Message text to be shown in the chat
    public let text: String


    public init(text: String) {
        self.text = text
    }
}

/// A new high score was achieved in a game
public struct MessageGameScore: Codable, Equatable, Hashable {

    /// Identifier of the game; may be different from the games presented in the message with the game
    public let gameId: TdInt64

    /// Identifier of the message with the game, can be an identifier of a deleted message
    public let gameMessageId: Int64

    /// New score
    public let score: Int


    public init(
        gameId: TdInt64,
        gameMessageId: Int64,
        score: Int
    ) {
        self.gameId = gameId
        self.gameMessageId = gameMessageId
        self.score = score
    }
}

/// A payment has been completed
public struct MessagePaymentSuccessful: Codable, Equatable, Hashable {

    /// Currency for the price of the product
    public let currency: String

    /// Identifier of the chat, containing the corresponding invoice message; 0 if unknown
    public let invoiceChatId: Int64

    /// Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
    public let invoiceMessageId: Int64

    /// Name of the invoice; may be empty if unknown
    public let invoiceName: String

    /// True, if this is the first recurring payment
    public let isFirstRecurring: Bool

    /// True, if this is a recurring payment
    public let isRecurring: Bool

    /// Total price for the product, in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        invoiceChatId: Int64,
        invoiceMessageId: Int64,
        invoiceName: String,
        isFirstRecurring: Bool,
        isRecurring: Bool,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoiceChatId = invoiceChatId
        self.invoiceMessageId = invoiceMessageId
        self.invoiceName = invoiceName
        self.isFirstRecurring = isFirstRecurring
        self.isRecurring = isRecurring
        self.totalAmount = totalAmount
    }
}

/// A payment has been completed; for bots only
public struct MessagePaymentSuccessfulBot: Codable, Equatable, Hashable {

    /// Currency for price of the product
    public let currency: String

    /// Invoice payload
    public let invoicePayload: Data

    /// True, if this is the first recurring payment
    public let isFirstRecurring: Bool

    /// True, if this is a recurring payment
    public let isRecurring: Bool

    /// Information about the order; may be null
    public let orderInfo: OrderInfo?

    /// Provider payment identifier
    public let providerPaymentChargeId: String

    /// Identifier of the shipping option chosen by the user; may be empty if not applicable
    public let shippingOptionId: String

    /// Telegram payment identifier
    public let telegramPaymentChargeId: String

    /// Total price for the product, in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        invoicePayload: Data,
        isFirstRecurring: Bool,
        isRecurring: Bool,
        orderInfo: OrderInfo?,
        providerPaymentChargeId: String,
        shippingOptionId: String,
        telegramPaymentChargeId: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoicePayload = invoicePayload
        self.isFirstRecurring = isFirstRecurring
        self.isRecurring = isRecurring
        self.orderInfo = orderInfo
        self.providerPaymentChargeId = providerPaymentChargeId
        self.shippingOptionId = shippingOptionId
        self.telegramPaymentChargeId = telegramPaymentChargeId
        self.totalAmount = totalAmount
    }
}

/// The current user has connected a website by logging in using Telegram Login Widget on it
public struct MessageWebsiteConnected: Codable, Equatable, Hashable {

    /// Domain name of the connected website
    public let domainName: String


    public init(domainName: String) {
        self.domainName = domainName
    }
}

/// Data from a Web App has been sent to a bot
public struct MessageWebAppDataSent: Codable, Equatable, Hashable {

    /// Text of the keyboardButtonTypeWebApp button, which opened the Web App
    public let buttonText: String


    public init(buttonText: String) {
        self.buttonText = buttonText
    }
}

/// Data from a Web App has been received; for bots only
public struct MessageWebAppDataReceived: Codable, Equatable, Hashable {

    /// Text of the keyboardButtonTypeWebApp button, which opened the Web App
    public let buttonText: String

    /// Received data
    public let data: String


    public init(
        buttonText: String,
        data: String
    ) {
        self.buttonText = buttonText
        self.data = data
    }
}

/// Telegram Passport data has been sent to a bot
public struct MessagePassportDataSent: Codable, Equatable, Hashable {

    /// List of Telegram Passport element types sent
    public let types: [PassportElementType]


    public init(types: [PassportElementType]) {
        self.types = types
    }
}

/// Telegram Passport data has been received; for bots only
public struct MessagePassportDataReceived: Codable, Equatable, Hashable {

    /// Encrypted data credentials
    public let credentials: EncryptedCredentials

    /// List of received Telegram Passport elements
    public let elements: [EncryptedPassportElement]


    public init(
        credentials: EncryptedCredentials,
        elements: [EncryptedPassportElement]
    ) {
        self.credentials = credentials
        self.elements = elements
    }
}

/// A user in the chat came within proximity alert range
public struct MessageProximityAlertTriggered: Codable, Equatable, Hashable {

    /// The distance between the users
    public let distance: Int

    /// The identifier of a user or chat that triggered the proximity alert
    public let travelerId: MessageSender

    /// The identifier of a user or chat that subscribed for the proximity alert
    public let watcherId: MessageSender


    public init(
        distance: Int,
        travelerId: MessageSender,
        watcherId: MessageSender
    ) {
        self.distance = distance
        self.travelerId = travelerId
        self.watcherId = watcherId
    }
}

